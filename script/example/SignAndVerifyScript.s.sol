// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import {console} from "forge-std/console.sol"; // Ensure console is imported if you're using it

contract SignAndVerifyScript is Script {
    using ECDSA for bytes32; // Allows calling .recover() on bytes32 message hashes

    function run() external {
        vm.startBroadcast();

        // --- PART 1: Simulate the Frontend Signature Generation (for comparison) ---
        // This part uses vm.sign to get a signature for comparison.
        // In a real scenario, this signature would come from the frontend.

        uint256 privateKey1 = vm.envUint("MINTER_PRIVATE_KEY_SEPOLIA");
        require(privateKey1 != 0, "MINTER_PRIVATE_KEY_SEPOLIA not set");

        address signerAddressForTesting = vm.addr(privateKey1);
        console.log("--- Testing Signature Generation (like Frontend) ---");
        console.log("Test Signer Address (from vm.addr):", signerAddressForTesting);

        // Use a fixed timestamp for consistent testing/comparison with frontend
        uint256 timestampForTesting = 1753257438;
        console.log("Test Timestamp:", uint32(timestampForTesting));

        // Create the original message hash: keccak256(abi.encodePacked(signer, timestamp))
        bytes32 originalMessageHash = keccak256(abi.encodePacked(signerAddressForTesting, timestampForTesting));
        console.log("Original Message Hash (bytes32):");
        console.logBytes32(originalMessageHash);

        // Apply the Ethereum Signed Message prefix and hash it again.
        // This is what `personal_sign` on the frontend does.
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(originalMessageHash);
        console.log("Eth Signed Message Hash (bytes32):"); 
        console.logBytes32(ethSignedMessageHash);

        // Get the signature using vm.sign for testing purposes
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey1, ethSignedMessageHash);
        bytes memory testSignatureFromVmSign = abi.encodePacked(r, s, v);

        console.log("Signature from vm.sign:");
        console.logBytes(testSignatureFromVmSign);

        // Verify the vm.sign signature within Solidity
        address recoveredFromVmSign = ethSignedMessageHash.recover(testSignatureFromVmSign);
        console.log("Recovered from vm.sign:", recoveredFromVmSign);
        console.log("Is Valid (vm.sign):", recoveredFromVmSign == signerAddressForTesting);


        // --- PART 2: The Production-Ready Verification Function ---
        // This is the function you would call from your frontend (or another contract)
        // passing the signature generated by the user's wallet.

        console.log("\n--- Production Verification Example ---");

        // Example: The signature and address that came from your Wagmi frontend
        // Replace with the actual signature and address you get from your Wagmi app's console output
        // when you sign with your browser wallet.
        // IMPORTANT: The `signerAddressFromFrontend` must be the address of the wallet that signed!
        address signerAddressFromFrontend = 0xdeF8De1110A2038Fa9fF863C3EC471847315faE8; // Example: Replace with your actual connected address
        uint256 timestampFromFrontend = 1753257438; // Example: Ensure this matches the timestamp from frontend

        // Get the signature from your Wagmi frontend console/UI.
        // Copy the "Signature" output from your Wagmi dApp's browser console or UI.
        bytes memory signatureFromFrontend = hex"2e93588041bbbef74f1b1bf6c562f48b4117fa415768e9b74af6d5824c467394778ab3ba641d59f6a5b0ca4cad701dfbdc054f7274d2c1137ee80f82543c476c1c";
        console.log("Signature from Frontend:");
        console.logBytes( signatureFromFrontend);

        // 1. Re-create the EXACT message hash that was signed on the frontend.
        // This is crucial: the message hash must be identical to what the frontend signed.
        bytes32 messageHashToVerify = keccak256(abi.encodePacked(signerAddressFromFrontend, timestampFromFrontend));
        console.log("Message Hash To Verify (bytes32):");
        console.logBytes32( messageHashToVerify);

        // 2. Apply the Ethereum Signed Message prefix and hash it again, exactly as the frontend wallet did.
        // This is why MessageHashUtils.toEthSignedMessageHash is important.
        bytes32 ethSignedMessageHashToVerify = MessageHashUtils.toEthSignedMessageHash(messageHashToVerify);
        console.log("Eth Signed Message Hash To Verify (bytes32):");
        console.logBytes32( ethSignedMessageHashToVerify);

        // 3. Recover the signer address using the signature from the frontend.
        address recoveredFromFrontendSig = ethSignedMessageHashToVerify.recover(signatureFromFrontend);

        console.log("Recovered from Frontend Signature:", recoveredFromFrontendSig);
        console.log("Is Valid (Frontend Sig):", recoveredFromFrontendSig == signerAddressFromFrontend);

        // In a real contract, you would have a function like this:
        // function verifyUserSignature(
        //     address _signer,
        //     uint256 _timestamp,
        //     bytes calldata _signature
        // ) public view returns (bool) {
        //     bytes32 _messageHash = keccak256(abi.encodePacked(_signer, _timestamp));
        //     bytes32 _ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(_messageHash);
        //     return _ethSignedMessageHash.recover(_signature) == _signer;
        // }


        vm.stopBroadcast();
    }
}